var

let   禁止重复声明，变量
const 禁止重复声明，常量

块级作用域

ES5的var的作用域--函数级
ES6的let的作用域--块级

代码块--{}

{

}

if(){

}

for() {

}


变量
var   重复声明，不能限制修改，函数级

let   不能，变量，块级
const 不能，常量，块级

const：
1.值不能修改
2.必须进行赋值   const name;
3.指向的对象不能修改，但是可以改变对象内部的属性
const obj={
  naem: 'hcl',
  age: 19
}
obj.name='aaa' 修改的是obj的属性 obj的地址还是没有变

--------------------------------------------------------------

对象的字面量增强写法

let name='hcl';
let age=18;
const obj= {
  name: name,
  age: age
}

ES6增强写法

const obj= {
  name,
  age
}
=============================================
let obj= {
  run: function () {
    console.log('123');
  }
}

ES6增强写法
let obj= {
  run() {
    console.log('123');
  }
}
--------------------------------------------------------------

解构赋值
json={a: 12,b: 5}
let {a,b}=json

arr=[123, 5, 6]
let [a,b,c]=arr

1.两边的结构必须一样
2.右边必须得是个东西
3.赋值和解构同时完成

不能是↓
let {a,b}=[12,5];   左边是json  右边是数组
let {a,b}={12,6};   左边是json  右边不是json格式

let {a,b};
{a,b}={a:12, b:5};  不能分开写
--------------------------------------------------------------

箭头函数
function (){

}

()=>{

}

上面两个等价

简写
1.如果有且仅有一个参数，()可以不写
2.如果有且仅有一条语句并且是return，{}也可以不写

--------------------------------------------------------------

箭头函数 修正this

问题：箭头函数中的this是如何查找的？
答案：向外层作用域中，一层层查找this，直到有this的定义

--------------------------------------------------------------


... 剩余参数
参数展开
  收集
  展开

数组展开
json展开
